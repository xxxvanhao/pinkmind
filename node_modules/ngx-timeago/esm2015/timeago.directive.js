/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Directive, Input, ElementRef, Optional, ChangeDetectorRef } from '@angular/core';
import { Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import { TimeagoClock } from './timeago.clock';
import { TimeagoFormatter } from './timeago.formatter';
import { TimeagoIntl } from './timeago.intl';
import { isDefined, coerceBooleanProperty, dateParser } from './util';
export class TimeagoDirective {
    /**
     * @param {?} intl
     * @param {?} cd
     * @param {?} formatter
     * @param {?} element
     * @param {?} clock
     */
    constructor(intl, cd, formatter, element, clock) {
        this.cd = cd;
        this.clock = clock;
        /**
         * Emits on:
         * - Input change
         * - Intl change
         * - Clock tick
         */
        this.stateChanges = new Subject();
        this._live = true;
        if (intl) {
            this.intlSubscription = intl.changes.subscribe(() => this.stateChanges.next());
        }
        this.stateChanges.subscribe(() => {
            this.setContent(element.nativeElement, formatter.format(this.date));
            this.cd.markForCheck();
        });
    }
    /**
     * The Date to display. An actual Date object or something that can be fed to new Date.
     * @return {?}
     */
    get date() {
        return this._date;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set date(date) {
        this._date = dateParser(date).valueOf();
        if (this._date) {
            if (this.clockSubscription) {
                this.clockSubscription.unsubscribe();
                this.clockSubscription = undefined;
            }
            this.clockSubscription = this.clock.tick(date)
                .pipe(filter(() => this.live, this))
                .subscribe(() => this.stateChanges.next());
        }
        else {
            throw new SyntaxError(`Wrong parameter in TimeagoDirective. Expected a valid date, received: ${date}`);
        }
    }
    /**
     * If the directive should update itself over time
     * @return {?}
     */
    get live() {
        return this._live;
    }
    /**
     * @param {?} live
     * @return {?}
     */
    set live(live) {
        this._live = coerceBooleanProperty(live);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.stateChanges.next();
    }
    /**
     * @param {?} node
     * @param {?} content
     * @return {?}
     */
    setContent(node, content) {
        if (isDefined(node.textContent)) {
            node.textContent = content;
        }
        else {
            node.data = content;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.intlSubscription) {
            this.intlSubscription.unsubscribe();
            this.intlSubscription = undefined;
        }
        if (this.clockSubscription) {
            this.clockSubscription.unsubscribe();
            this.clockSubscription = undefined;
        }
        this.stateChanges.complete();
    }
}
TimeagoDirective.decorators = [
    { type: Directive, args: [{
                selector: '[timeago]',
                exportAs: 'timeago',
            },] },
];
/** @nocollapse */
TimeagoDirective.ctorParameters = () => [
    { type: TimeagoIntl, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: TimeagoFormatter },
    { type: ElementRef },
    { type: TimeagoClock }
];
TimeagoDirective.propDecorators = {
    date: [{ type: Input }],
    live: [{ type: Input }]
};
function TimeagoDirective_tsickle_Closure_declarations() {
    /** @type {?} */
    TimeagoDirective.prototype.intlSubscription;
    /** @type {?} */
    TimeagoDirective.prototype.clockSubscription;
    /**
     * Emits on:
     * - Input change
     * - Intl change
     * - Clock tick
     * @type {?}
     */
    TimeagoDirective.prototype.stateChanges;
    /** @type {?} */
    TimeagoDirective.prototype._date;
    /** @type {?} */
    TimeagoDirective.prototype._live;
    /** @type {?} */
    TimeagoDirective.prototype.cd;
    /** @type {?} */
    TimeagoDirective.prototype.clock;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZWFnby5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtdGltZWFnby8iLCJzb3VyY2VzIjpbInRpbWVhZ28uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxVQUFVLEVBQ1YsUUFBUSxFQUlSLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQWdCLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsU0FBUyxFQUFFLHFCQUFxQixFQUFFLFVBQVUsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQU10RSxNQUFNOzs7Ozs7OztJQTJDSixZQUF3QixJQUFpQixFQUNyQixJQUNSLFNBQTJCLEVBQzNCLE9BQW1CLEVBQ1g7UUFIQSxPQUFFLEdBQUYsRUFBRTtRQUdGLFVBQUssR0FBTCxLQUFLOzs7Ozs7OzRCQXJDVixJQUFJLE9BQU8sRUFBTztxQkErQmpCLElBQUk7UUFPbEIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNULElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDaEY7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDcEUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN4QixDQUFDLENBQUM7S0FDSjs7Ozs7SUExQ0QsSUFDSSxJQUFJO1FBQ04sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDbkI7Ozs7O0lBQ0QsSUFBSSxJQUFJLENBQUMsSUFBWTtRQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN4QyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNmLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDckMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsQ0FBQzthQUNwQztZQUNELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7aUJBQzNDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDbkMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUM5QztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sTUFBTSxJQUFJLFdBQVcsQ0FBQyx5RUFBeUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUN4RztLQUNGOzs7OztJQUlELElBQ0ksSUFBSTtRQUNOLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQ25COzs7OztJQUNELElBQUksSUFBSSxDQUFDLElBQWE7UUFDcEIsSUFBSSxDQUFDLEtBQUssR0FBRyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMxQzs7Ozs7SUFpQkQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDMUI7Ozs7OztJQUVELFVBQVUsQ0FBQyxJQUFTLEVBQUUsT0FBZTtRQUNuQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQztTQUM1QjtRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sSUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7U0FDckI7S0FDRjs7OztJQUVELFdBQVc7UUFDVCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxDQUFDO1NBQ25DO1FBQ0QsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUMzQixJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsQ0FBQztTQUNwQztRQUNELElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDOUI7OztZQW5GRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLFdBQVc7Z0JBQ3JCLFFBQVEsRUFBRSxTQUFTO2FBQ3BCOzs7O1lBTlEsV0FBVyx1QkFrREwsUUFBUTtZQXhEckIsaUJBQWlCO1lBS1YsZ0JBQWdCO1lBVnZCLFVBQVU7WUFTSCxZQUFZOzs7bUJBc0JsQixLQUFLO21CQXFCTCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBJbnB1dCxcbiAgRWxlbWVudFJlZixcbiAgT3B0aW9uYWwsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBDaGFuZ2VEZXRlY3RvclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGltZWFnb0Nsb2NrIH0gZnJvbSAnLi90aW1lYWdvLmNsb2NrJztcbmltcG9ydCB7IFRpbWVhZ29Gb3JtYXR0ZXIgfSBmcm9tICcuL3RpbWVhZ28uZm9ybWF0dGVyJztcbmltcG9ydCB7IFRpbWVhZ29JbnRsIH0gZnJvbSAnLi90aW1lYWdvLmludGwnO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBjb2VyY2VCb29sZWFuUHJvcGVydHksIGRhdGVQYXJzZXIgfSBmcm9tICcuL3V0aWwnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdGltZWFnb10nLFxuICBleHBvcnRBczogJ3RpbWVhZ28nLFxufSlcbmV4cG9ydCBjbGFzcyBUaW1lYWdvRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGludGxTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBjbG9ja1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBvbjpcbiAgICogLSBJbnB1dCBjaGFuZ2VcbiAgICogLSBJbnRsIGNoYW5nZVxuICAgKiAtIENsb2NrIHRpY2tcbiAgKi9cbiAgc3RhdGVDaGFuZ2VzID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gIC8qKiBUaGUgRGF0ZSB0byBkaXNwbGF5LiBBbiBhY3R1YWwgRGF0ZSBvYmplY3Qgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGZlZCB0byBuZXcgRGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRhdGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgfVxuICBzZXQgZGF0ZShkYXRlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9kYXRlID0gZGF0ZVBhcnNlcihkYXRlKS52YWx1ZU9mKCk7XG4gICAgaWYgKHRoaXMuX2RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmNsb2NrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9ja1N1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24gPSB0aGlzLmNsb2NrLnRpY2soZGF0ZSlcbiAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMubGl2ZSwgdGhpcykpXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBXcm9uZyBwYXJhbWV0ZXIgaW4gVGltZWFnb0RpcmVjdGl2ZS4gRXhwZWN0ZWQgYSB2YWxpZCBkYXRlLCByZWNlaXZlZDogJHtkYXRlfWApO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9kYXRlOiBudW1iZXI7XG5cbiAgLyoqIElmIHRoZSBkaXJlY3RpdmUgc2hvdWxkIHVwZGF0ZSBpdHNlbGYgb3ZlciB0aW1lICovXG4gIEBJbnB1dCgpXG4gIGdldCBsaXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9saXZlO1xuICB9XG4gIHNldCBsaXZlKGxpdmU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9saXZlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KGxpdmUpO1xuICB9XG4gIHByaXZhdGUgX2xpdmUgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIGludGw6IFRpbWVhZ29JbnRsLFxuICAgICAgICAgICAgICBwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgZm9ybWF0dGVyOiBUaW1lYWdvRm9ybWF0dGVyLFxuICAgICAgICAgICAgICBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIGNsb2NrOiBUaW1lYWdvQ2xvY2spIHtcbiAgICBpZiAoaW50bCkge1xuICAgICAgdGhpcy5pbnRsU3Vic2NyaXB0aW9uID0gaW50bC5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCkpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlQ2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRDb250ZW50KGVsZW1lbnQubmF0aXZlRWxlbWVudCwgZm9ybWF0dGVyLmZvcm1hdCh0aGlzLmRhdGUpKTtcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICB9XG5cbiAgc2V0Q29udGVudChub2RlOiBhbnksIGNvbnRlbnQ6IHN0cmluZykge1xuICAgIGlmIChpc0RlZmluZWQobm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRhdGEgPSBjb250ZW50O1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmludGxTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5pbnRsU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5jbG9ja1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jbG9ja1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5jbG9ja1N1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZUNoYW5nZXMuY29tcGxldGUoKTtcbiAgfVxufVxuIl19